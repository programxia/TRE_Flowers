

globalptr	RN r10 ;//=wram_globals* ptr 6502的基准指针
;----------------------------------------------------------------------------

 MAP 0,globalptr		  ;//MAP 用于定义一个结构化的内存表的首地址
				;//6502.s	  ;//定义内存表的首地址为globalptr
opz #   4              ;opz # 256*4       ;//代码表地址					  
readmem_tbl # 8*4			  ;//8*4
writemem_tbl # 8*4			  ;//8*4
memmap_tbl # 8*4			 ;//存储器映象 ram+rom
cpuregs # 7*4				 ;//1208存放6502寄存器保存的开始地址
m6502_s # 4					 ;//
lastbank # 4				;//6502PC从 ROM的最后偏移量
nexttimeout # 4

rombase # 4			;//ROM开始地址
romnumber # 4		 ;// ROM大小  
rommask # 4		   ;//ROM掩膜	rommask=romsize-1

joy0data # 4	   ;//串行数据
joy1data # 4	   ;//手柄1串行数据

clocksh # 4    ;//执行的时钟数 apu用
cpunmif # 4      ;cpu中断标志
cpuirqf # 4      ;cpu中断标志   43*4
;***********************************************************************************************
C EQU 0x01	;//6502 flags  6502标志
Z EQU 0x02
I EQU 0x04
D EQU 0x08
B EQU 0x10	;//(allways 1 except when IRQ pushes it)IRQ外部中断
R EQU 0x20	;//(locked at 1)
V EQU 0x40
N EQU 0x80

	MACRO		;//translate from 6502 PC to rom offset翻译从6502 PC ROM的偏移量
	encodePC
	and r1,m6502_pc,#0xE000	   ;//r9和0xe000按位与运算
	adr r2,memmap_tbl		   ;//把存储器映象地址加载到r2
;//	ldr r0,[r2,r1,lsr#11]	   ;//改过，加2行 
	lsr r0,r1,#11				;//>>11位	  r1/2048
	ldr r0,[r2,r0]				;//读取r2地址+r1偏移的数据到r0
	
	str r0,lastbank				;//保存6502PC从 ROM的最后偏移量 
	add m6502_pc,m6502_pc,r0	;//m6502_pc+r0
	MEND

	MACRO		;//pack 6502 flags into r0   6502标志包装到R0
	encodeP $extra
	and r0,cycles,#CYC_V+CYC_D+CYC_I+CYC_C
	tst m6502_nz,#0x80000000;//PSR_N
	orrne r0,r0,#N				;N
	tst m6502_nz,#0xff
	orreq r0,r0,#Z				;Z
	orr r0,r0,#$extra			;R(&B)
	MEND

	MACRO		;//;宏定义//unpack 6502 flags from r0	  解压缩6502从R0的标志
	decodeP
	bic cycles,cycles,#CYC_V+CYC_D+CYC_I+CYC_C
	and r1,r0,#V+D+I+C
	orr cycles,cycles,r1		;//VDIC
	bic m6502_nz,r0,#0xFD			;//r0 is signed
	eor m6502_nz,m6502_nz,#Z
	MEND		;//		  ;宏定义结束

	MACRO
	fetch $count			   ;//提取操作码	;$标号 宏名 $参数1，$参数2，...
;//---------------------------------------------------------------------
	ldr r0,clocksh			   ;//处理apu需要的时钟数
	add r0,r0,#$count
	str r0,clocksh

	ldr r1,opz            ;//获取代码跳转表地址
;//-------------------------------------------------------------------------
	subs cycles,cycles,#$count*256;//CYCLE=256 ;//	3*256 正数或0就执行下2条指令  
	ldrplb r0,[m6502_pc],#1			   ; //从存储器中加载字节到一个寄存器中	 r0=操作码
;	ldrpl pc,[m6502_optbl,r0,lsl#2]	  ;//r10 ********r0=r0x4***运行代码的地址**************************************
	ldrpl pc,[r1,r0,lsl#2]
	ldr pc,nexttimeout
	MEND

	MACRO						;//相同的提取，但它增加了进位（位0）
	fetch_c $count				;//same as fetch except it adds the Carry (bit 0) also.
;//---------------------------------------------------------------------
	ldr r0,clocksh				;//处理apu需要的时钟数
	add r0,r0,#$count
	str r0,clocksh	
	
	ldr r1,opz       ;//获取代码跳转表地址
;//-------------------------------------------------------------------------
	sbcs cycles,cycles,#$count*256;//CYCLE=256
	ldrplb r0,[m6502_pc],#1
;	ldrpl pc,[m6502_optbl,r0,lsl#2]
	ldrpl pc,[r1,r0,lsl#2]
	ldr pc,nexttimeout
	MEND

	MACRO
	clearcycles
	and cycles,cycles,#CYC_MASK		;Save CPU bits
	MEND

	MACRO
	readmemabs
	and r1,addy,#0xE000
	adr lr,%F0
;//	ldr pc,[m6502_rmem,r1,lsr#11]	;//in: addy,r1=addy&0xE000 (for rom_R)
	lsr r1,r1,#11				 ;//改过，加2行	 >>11
	ldr pc,[m6502_rmem,r1]
				
0				;//out: r0=val (bits 8-31=0 (LSR,ROR,INC,DEC,ASL)), addy preserved for RMW instructions
	MEND

	MACRO
	readmemzp
	ldrb r0,[cpu_zpage,addy]
	MEND

	MACRO
	readmemzpi
;//	ldrb r0,[cpu_zpage,addy,lsr#24]
	lsr r0,addy,#24				  ;//改过，加3行
	ldrb r0,[cpu_zpage,r0]

	MEND

	MACRO
	readmemzps
	ldrsb m6502_nz,[cpu_zpage,addy];RAM
	MEND

	MACRO
	readmemimm
	ldrb r0,[m6502_pc],#1  ;ROM
	MEND

	MACRO
	readmemimms
	ldrsb m6502_nz,[m6502_pc],#1
	MEND

	MACRO
	readmem
	[ _type = _ABS
		readmemabs
	]
	[ _type = _ZP
		readmemzp
	]
	[ _type = _ZPI
		readmemzpi
	]
	[ _type = _IMM
		readmemimm
	]
	MEND

	MACRO
	readmems
	[ _type = _ABS
		readmemabs
		orr m6502_nz,r0,r0,lsl#24
	]
	[ _type = _ZP
		readmemzps
	]
	[ _type = _IMM
		readmemimms
	]
	MEND


	MACRO
	writememabs
	and r1,addy,#0xe000
	adr r2,writemem_tbl
	adr lr,%F0
;//	ldr pc,[r2,r1,lsr#11]	;//in: addy,r0=val(bits 8-31=?)
	lsr r1,r1,#11				 ;//改过，加2行 >>11
	ldr pc,[r2,r1]

0				;out: r0,r1,r2,addy=?
	MEND

	MACRO
	writememzp
	strb r0,[cpu_zpage,addy]
	MEND

	MACRO
	writememzpi
;//	strb r0,[cpu_zpage,addy,lsr#24]
	lsr r1,addy,#24				 ;//改过，加2行	 >>24
	strb r0,[cpu_zpage,r1]


	MEND

	MACRO
	writemem			   ;//写内存
	[ _type = _ABS
		writememabs
	]
	[ _type = _ZP
		writememzp
	]
	[ _type = _ZPI
		writememzpi
	]
	MEND
;----------------------------------------------------------------------------

	MACRO					  ;///////////////////////////////// /////////////////////
	push16		;push r0
	mov r1,r0,lsr#8
	ldr r2,m6502_s
	strb r1,[r2],#-1
	orr r2,r2,#0x100
	strb r0,[r2],#-1
	strb r2,m6502_s
	MEND		;r1,r2=?

	MACRO
	push8 $x
	ldr r2,m6502_s
	strb $x,[r2],#-1
	strb r2,m6502_s
	MEND		;r2=?

	MACRO
	pop16		;pop m6502_pc
	ldrb r2,m6502_s
	add r2,r2,#2
	strb r2,m6502_s
	ldr r2,m6502_s
	ldrb r0,[r2],#-1
	orr r2,r2,#0x100
	ldrb m6502_pc,[r2]
	orr m6502_pc,m6502_pc,r0,lsl#8
	MEND		;r0,r1=?

	MACRO
	pop8 $x
	ldrb r2,m6502_s
	add r2,r2,#1
	strb r2,m6502_s
	orr r2,r2,#0x100
	ldrsb $x,[cpu_zpage,r2]		;signed for PLA & PLP

	MEND	;r2=?

;----------------------------------------------------------------------------
;doXXX: load addy, increment m6502_pc

	GBLA _type

_IMM	EQU 1						;immediate
_ZP		EQU 2						;zero page
_ZPI	EQU 3						;zero page indexed
_ABS	EQU 4						;absolute

	MACRO
	doABS                           ;absolute               $nnnn
_type	SETA      _ABS
	ldrb addy,[m6502_pc],#1
	ldrb r0,[m6502_pc],#1
	orr addy,addy,r0,lsl#8
	MEND

	MACRO
	doAIX                           ;absolute indexed X     $nnnn,X
_type	SETA      _ABS
	ldrb addy,[m6502_pc],#1
	ldrb r0,[m6502_pc],#1
	orr addy,addy,r0,lsl#8
	add addy,addy,m6502_x,lsr#24
;	bic addy,addy,#0xff0000 ;Base Wars needs this
	MEND

	MACRO
	doAIY                           ;absolute indexed Y     $nnnn,Y
_type	SETA      _ABS
	ldrb addy,[m6502_pc],#1
	ldrb r0,[m6502_pc],#1
	orr addy,addy,r0,lsl#8
	add addy,addy,m6502_y,lsr#24
;	bic addy,addy,#0xff0000 ;Tecmo Bowl needs this
	MEND

	MACRO
	doIMM                           ;immediate              #$nn
_type	SETA      _IMM
	MEND

	MACRO
	doIIX                           ;indexed indirect X     ($nn,X)
_type	SETA      _ABS
	ldrb r0,[m6502_pc],#1
	add r0,m6502_x,r0,lsl#24
	;//ldrb addy,[cpu_zpage,r0,lsr#24]	;//错误:指定的转变不允许
    lsr addy,r0,#24			  ;//改过，加2行 >>24
	ldrb addy,[cpu_zpage,addy]

	add r0,r0,#0x01000000
	;//ldrb r1,[cpu_zpage,r0,lsr#24]	;//R1,LSR#2;将R1中的内容右移2位
	lsr r1,r0,#24			  ;//改过，加2行
	ldrb r1,[cpu_zpage,r1]

	orr addy,addy,r1,lsl#8
	MEND

	MACRO
	doIIY                           ;indirect indexed Y     ($nn),Y
_type	SETA      _ABS
	ldrb r0,[m6502_pc],#1
;//	ldrb addy,[r0,cpu_zpage]! ;;在数据传送之前,将偏移量加到Rn 中,其结果作为传送数据的存储地址
                            ;//若使用后缀"!",则结果写回到Rn中
	ldrb addy,[r0,cpu_zpage]
	add r0,r0,cpu_zpage			;//////////////////////////////////////


	ldrb r1,[r0,#1]
	orr addy,addy,r1,lsl#8
	add addy,addy,m6502_y,lsr#24
;	bic addy,addy,#0xff0000 ;Zelda2 needs this
	MEND

	MACRO
	doZPI							;Zeropage indirect     ($nn)
_type	SETA      _ABS
	ldrb r0,[m6502_pc],#1
;//	ldrb addy,[r0,cpu_zpage]!;;在数据传送之前,将偏移量加到Rn 中,其结果作为传送数据的存储地址
                            ;//若使用后缀"!",则结果写回到Rn中
	ldrb addy,[r0,cpu_zpage]
	add r0,r0,cpu_zpage	
	
	
	ldrb r1,[r0,#1]
	orr addy,addy,r1,lsl#8
	MEND

	MACRO
	doZ                             ;zero page              $nn
_type	SETA      _ZP
	ldrb addy,[m6502_pc],#1
	MEND

	MACRO
	doZ2							;zero page              $nn
_type	SETA      _ZP
	ldrb addy,[m6502_pc],#2			;ugly thing for bbr/bbs
	MEND

	MACRO
	doZIX                           ;zero page indexed X    $nn,X
_type	SETA      _ZP
	ldrb addy,[m6502_pc],#1
	add addy,addy,m6502_x,lsr#24
	and addy,addy,#0xff ;Rygar needs this
	MEND

	MACRO
	doZIXf							;zero page indexed X    $nn,X
_type	SETA      _ZPI
	ldrb addy,[m6502_pc],#1
	add addy,m6502_x,addy,lsl#24
	MEND

	MACRO
	doZIY                           ;zero page indexed Y    $nn,Y
_type	SETA      _ZP
	ldrb addy,[m6502_pc],#1
	add addy,addy,m6502_y,lsr#24
	and addy,addy,#0xff
	MEND

	MACRO
	doZIYf							;zero page indexed Y    $nn,Y
_type	SETA      _ZPI
	ldrb addy,[m6502_pc],#1
	add addy,m6502_y,addy,lsl#24
	MEND

;----------------------------------------------------------------------------

	MACRO
	opADC
	readmem
	movs r1,cycles,lsr#1		;get C
	subcs r0,r0,#0x00000100
	adcs m6502_a,m6502_a,r0,ror#8
	mov m6502_nz,m6502_a,asr#24		;NZ
	orr cycles,cycles,#CYC_C+CYC_V	;Prepare C & V
	bicvc cycles,cycles,#CYC_V	;V
	MEND

	MACRO
	opAND
	readmem
	and m6502_a,m6502_a,r0,lsl#24
	mov m6502_nz,m6502_a,asr#24		;NZ
	MEND

	MACRO
	opASL
	readmem
	 add r0,r0,r0
	 orrs m6502_nz,r0,r0,lsl#24		;NZ
	 orr cycles,cycles,#CYC_C		;Prepare C
	writemem
	MEND

	MACRO
	opBIT
	readmem
	bic cycles,cycles,#CYC_V		;reset V
	tst r0,#V
	orrne cycles,cycles,#CYC_V		;V
	and m6502_nz,r0,m6502_a,lsr#24	;Z
	orr m6502_nz,m6502_nz,r0,lsl#24	;N
	MEND

	MACRO
	opCOMP $x			;A,X & Y
	readmem
	subs m6502_nz,$x,r0,lsl#24
	mov m6502_nz,m6502_nz,asr#24	;NZ
	orr cycles,cycles,#CYC_C	;Prepare C
	MEND

	MACRO
	opDEC
	readmem
	sub r0,r0,#1
	orr m6502_nz,r0,r0,lsl#24		;NZ
	writemem
	MEND

	MACRO
	opEOR
	readmem
	eor m6502_a,m6502_a,r0,lsl#24
	mov m6502_nz,m6502_a,asr#24		;NZ
	MEND

	MACRO
	opINC
	readmem
	add r0,r0,#1
	orr m6502_nz,r0,r0,lsl#24		;NZ
	writemem
	MEND

	MACRO
	opLOAD $x
	readmems
	mov $x,m6502_nz,lsl#24
	MEND

	MACRO
	opLSR
	[ _type = _ABS
		readmemabs
		movs r0,r0,lsr#1
		orr cycles,cycles,#CYC_C	;Prepare C
		mov m6502_nz,r0				;Z, (N=0)
		writememabs
	]
	[ _type = _ZP
		ldrb m6502_nz,[cpu_zpage,addy]
		movs m6502_nz,m6502_nz,lsr#1	;Z, (N=0)
		orr cycles,cycles,#CYC_C	;Prepare C
		strb m6502_nz,[cpu_zpage,addy]
	]
	[ _type = _ZPI
;//		ldrb m6502_nz,[cpu_zpage,addy,lsr#24]
		lsr m6502_nz,addy,#24				  ;//改过，加2行
		ldrb m6502_nz,[cpu_zpage,m6502_nz]

		movs m6502_nz,m6502_nz,lsr#1	;Z, (N=0)
		orr cycles,cycles,#CYC_C	;Prepare C
;//		strb m6502_nz,[cpu_zpage,addy,lsr#24]
		lsr r1,addy,#24				   ;//改过，加2行
		strb m6502_nz,[cpu_zpage,r1]
										 
	]
	MEND

	MACRO
	opORA
	readmem
	orr m6502_a,m6502_a,r0,lsl#24
	mov m6502_nz,m6502_a,asr#24
	MEND

	MACRO
	opROL
	readmem
	 movs cycles,cycles,lsr#1		;get C
	 adc r0,r0,r0
	 orrs m6502_nz,r0,r0,lsl#24		;NZ
	 adc cycles,cycles,cycles		;Set C
	writemem
	MEND

	MACRO
	opROR
	readmem
	 movs cycles,cycles,lsr#1		;get C
	 orrcs r0,r0,#0x100
	 movs r0,r0,lsr#1
	 orr m6502_nz,r0,r0,lsl#24		;NZ
	 adc cycles,cycles,cycles		;Set C
	writemem
	MEND

	MACRO
	opSBC
	readmem
	movs r1,cycles,lsr#1			;get C
	sbcs m6502_a,m6502_a,r0,lsl#24
	and m6502_a,m6502_a,#0xff000000
	mov m6502_nz,m6502_a,asr#24 		;NZ
	orr cycles,cycles,#CYC_C+CYC_V	;Prepare C & V
	bicvc cycles,cycles,#CYC_V		;V
	MEND

	MACRO
	opSTORE $x
	mov r0,$x,lsr#24
	writemem
	MEND
;*************************************************************************************************

	IMPORT NES_RAM		 ;nes_main.c   __align(1024) uint8 NES_RAM[0x800];//保持1024字节对齐
	IMPORT NES_SRAM		 ;nes_main.c   uint8 NES_SRAM[0x2000];	
	IMPORT spr_ram		 ;             uint8 spr_ram[0x100];
	IMPORT romfile ;from main.c	

	EXPORT cpunmi    ;cpu中断标志
	EXPORT cpuirq    ;cpu中断标志 
	EXPORT clocks    ;apu要的cpu时钟
	EXPORT cpu_data	   ;地址 cart.s
	EXPORT rommap
	EXPORT NMI6502
	EXPORT CPU_reset
	EXPORT run6502
		
	EXPORT cpu6502_init
	EXPORT map67_	
	EXPORT map67_0	
	EXPORT map89_
	EXPORT mapAB_
	EXPORT mapCD_
	EXPORT mapEF_	
	EXPORT map89ABCDEF_

IRQ_VECTOR		EQU 0xfffe ; //IRQ / BRK中断向量地址
RES_VECTOR		EQU 0xfffc ;// 复位中断向量地址
NMI_VECTOR		EQU 0xfffa ;// NMI中断向量地址

;cycle flags- (stored in cycles reg for speed)存储在周期章速度

CYC_C			EQU 0x01	;Carry bit 进位
;BRANCH			EQU 0x02	;branch instruction encountered	遇到分支指令
CYC_I			EQU 0x04	;IRQ mask
CYC_D			EQU 0x08	;Decimal bit	小数位
CYC_V			EQU 0x40	;Overflow bit	 溢出位
;CYC_MASK		EQU 0xFF;CYCLE-1	;Mask

   AREA cpu_code, CODE, READONLY ;, ALIGN=2
											;	不要对 ARM 代码节使用 ALIGN=0 或 ALIGN=1。
                                           ;    不要对 Thumb 代码节使用 ALIGN=0。
   ;AREA  伪代码也是需要语法的，AREA  后面跟着段名标号，然后是属性，CODE 表示这是一 
	;个代码段，READONLY 表示这个段是只读的
	;|.text|系统默认的代码段名  
	; ALIGN 指令通过用零或 NOP 指令进行填充将当前位置对齐到指定边界
	;ENTRY  这个伪代码是用来定义入口点
	THUMB	 ;Thumb是ARM体系结构中一种16位的指令集
;	REQUIRE8  ;REQUIRE8 指令指定当前文件要求堆栈八字节对齐。 它设置 REQ8 编译属性以通知链接器。
	PRESERVE8 ;{TRUE} ;PRESERVE8 指令指定当前文件保持堆栈八字节对齐。 它设置 PRES8 编译属性以通知链接器。
			  ;如果您省略 PRESERVE8 和 PRESERVE8 {FALSE}，汇编程序会检查修改 sp 的指令，
			  ;以决定是否设置 PRES8 编译属性。 ARM 建议明确指定 PRESERVE8。
			  ; ARM使用r0作为返回值
			  ;参数传递ARM：寄存器到堆栈，首先将参数赋给r0, r1等

 ;  PROC 为子程序开始，ENDP 为子程序结束


		;r0,r1,r2=temp regs	  
m6502_nz	RN r3 ;bit 31=N, Z=1 if bits 0-7=0		  ;RN定义寄存器名
m6502_rmem	RN r4 ;readmem_tbl
m6502_a		RN r5 ;//bits 0-23=0, 还用于清除在内存中的字节
m6502_x		RN r6 ;bits 0-23=0
m6502_y		RN r7 ;bits 0-23=0
cycles		RN r8 ;//also VDIC flags也VDIC标志
m6502_pc	RN r9
globalptr	RN r10 ;=wram_globals* ptr
m6502_optbl	RN r10
cpu_zpage	RN r11 ;=CPU_RAM
addy		RN r12 ;//keep this at r12 (从头 APCS)	//addr  :代表8位地址 
		;r13=SP
		;r14=LR
		;r15=PC
;---------------------------------------------------
	

_00;   BRK
;----------------------------------------------------------------------------

	ldr r0,lastbank		 ;	  6502PC从 ROM的最后偏移量
	sub r1,m6502_pc,r0
	add r0,r1,#1
	push16			;save PC

	encodeP (B+R)		;save P

	ldr r12,=IRQ_VECTOR
	bl VecCont

	fetch 7
	LTORG			 ;指令， LTORG可能是在一个可执行的位置
;----------------------------------------------------------------------------
_01;   ORA ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opORA
	fetch 6
;----------------------------------------------------------------------------
_05;   ORA $nn
;----------------------------------------------------------------------------
	doZ
	opORA
	fetch 3
;----------------------------------------------------------------------------
_06;   ASL $nn
;----------------------------------------------------------------------------
	doZ
	opASL
	fetch_c 5
;----------------------------------------------------------------------------
_08;   PHP
;----------------------------------------------------------------------------
	encodeP (B+R)
	push8 r0
	fetch 3
;----------------------------------------------------------------------------
_09;   ORA #$nn
;----------------------------------------------------------------------------
	doIMM
	opORA
	fetch 2
;----------------------------------------------------------------------------
_0A;   ASL
;----------------------------------------------------------------------------
	adds m6502_a,m6502_a,m6502_a
	mov m6502_nz,m6502_a,asr#24		;NZ
	orr cycles,cycles,#CYC_C		;Prepare C
	fetch_c 2						;also subs carry
;----------------------------------------------------------------------------
_0D;   ORA $nnnn
;----------------------------------------------------------------------------
	doABS
	opORA
	fetch 4
;----------------------------------------------------------------------------
_0E;   ASL $nnnn
;----------------------------------------------------------------------------
	doABS
	opASL
	fetch_c 6
;----------------------------------------------------------------------------	 
_10;   BPL *
;----------------------------------------------------------------------------
	tst m6502_nz,#0x80000000
	ldrsb r0,[m6502_pc],#1
	addeq m6502_pc,m6502_pc,r0
;	subeq cycles,cycles,#3*CYCLE
	subeq cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_11;   ORA ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opORA
	fetch 5
;----------------------------------------------------------------------------
_15;   ORA $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opORA
	fetch 4
;----------------------------------------------------------------------------
_16;   ASL $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opASL
	fetch_c 6
;----------------------------------------------------------------------------
_18;   CLC
;----------------------------------------------------------------------------
	bic cycles,cycles,#CYC_C
	fetch 2
;----------------------------------------------------------------------------
_19;   ORA $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opORA
	fetch 4
;----------------------------------------------------------------------------
_1D;   ORA $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opORA
	fetch 4
;----------------------------------------------------------------------------
_1E;   ASL $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opASL
	fetch_c 7
;----------------------------------------------------------------------------
_20;   JSR $nnnn
;----------------------------------------------------------------------------
	ldrb r2,[m6502_pc],#1
	ldr r1,lastbank
	sub r0,m6502_pc,r1
	ldrb r1,[m6502_pc]
	orr m6502_pc,r2,r1,lsl#8
	push16
	encodePC
	fetch 6
;----------------------------------------------------------------------------
_21;   AND ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opAND
	fetch 6
;----------------------------------------------------------------------------
_24;   BIT $nn
;----------------------------------------------------------------------------
	doZ
	opBIT
	fetch 3
;----------------------------------------------------------------------------
_25;   AND $nn
;----------------------------------------------------------------------------
	doZ
	opAND
	fetch 3
;----------------------------------------------------------------------------
_26;   ROL $nn
;----------------------------------------------------------------------------
	doZ
	opROL
	fetch 5
;----------------------------------------------------------------------------
_28;   PLP
;----------------------------------------------------------------------------
	pop8 r0
	decodeP
	fetch 4
;----------------------------------------------------------------------------
_29;   AND #$nn
;----------------------------------------------------------------------------
	doIMM
	opAND
	fetch 2
;----------------------------------------------------------------------------
_2A;   ROL
;----------------------------------------------------------------------------
	movs cycles,cycles,lsr#1		;get C
	orrcs m6502_a,m6502_a,#0x00800000
	adds m6502_a,m6502_a,m6502_a
	mov m6502_nz,m6502_a,asr#24		;NZ
	adc cycles,cycles,cycles		;Set C
	fetch 2
;----------------------------------------------------------------------------
_2C;   BIT $nnnn
;----------------------------------------------------------------------------
	doABS
	opBIT
	fetch 4
;----------------------------------------------------------------------------
_2D;   AND $nnnn
;----------------------------------------------------------------------------
	doABS
	opAND
	fetch 4
;----------------------------------------------------------------------------
_2E;   ROL $nnnn
;----------------------------------------------------------------------------
	doABS
	opROL
	fetch 6
;----------------------------------------------------------------------------
_30;   BMI *
;----------------------------------------------------------------------------
	tst m6502_nz,#0x80000000
	ldrsb r0,[m6502_pc],#1
	addne m6502_pc,m6502_pc,r0
;	subne cycles,cycles,#3*CYCLE
	subne cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_31;   AND ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opAND
	fetch 5
;----------------------------------------------------------------------------
_35;   AND $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opAND
	fetch 4
;----------------------------------------------------------------------------
_36;   ROL $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opROL
	fetch 6
;----------------------------------------------------------------------------
_38;   SEC
;----------------------------------------------------------------------------
	orr cycles,cycles,#CYC_C
	fetch 2
;----------------------------------------------------------------------------
_39;   AND $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opAND
	fetch 4
;----------------------------------------------------------------------------
_3D;   AND $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opAND
	fetch 4
;----------------------------------------------------------------------------
_3E;   ROL $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opROL
	fetch 7
;----------------------------------------------------------------------------
_40;   RTI
;----------------------------------------------------------------------------
	pop8 r0		;pop 6502 flags and decode
	decodeP
	pop16		;pop the return address
	encodePC
	fetch 6
;----------------------------------------------------------------------------
_41;   EOR ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opEOR
	fetch 6
;----------------------------------------------------------------------------
_45;   EOR $nn
;----------------------------------------------------------------------------
	doZ
	opEOR
	fetch 3
;----------------------------------------------------------------------------
_46;   LSR $nn
;----------------------------------------------------------------------------
	doZ
	opLSR
	fetch_c 5
;----------------------------------------------------------------------------
_48;   PHA
;----------------------------------------------------------------------------
	mov r0,m6502_a,lsr#24
	push8 r0
	fetch 3
;----------------------------------------------------------------------------
_49;   EOR #$nn
;----------------------------------------------------------------------------
	doIMM
	opEOR
	fetch 2
;----------------------------------------------------------------------------
_4A;   LSR
;----------------------------------------------------------------------------
	movs m6502_nz,m6502_a,lsr#25	;Z, N=0
	mov m6502_a,m6502_nz,lsl#24		;result without garbage
	orr cycles,cycles,#CYC_C		;Prepare C
	fetch_c 2
;----------------------------------------------------------------------------
_4C;   JMP $nnnn
;----------------------------------------------------------------------------
	ldrb r0,[m6502_pc],#1
	ldrb r1,[m6502_pc]
	orr m6502_pc,r0,r1,lsl#8
	encodePC
	fetch 3
;----------------------------------------------------------------------------
_4D;   EOR $nnnn
;----------------------------------------------------------------------------
	doABS
	opEOR
	fetch 4
;----------------------------------------------------------------------------
_4E;   LSR $nnnn
;----------------------------------------------------------------------------
	doABS
	opLSR
	fetch_c 6
;----------------------------------------------------------------------------
_50;   BVC *
;----------------------------------------------------------------------------
	tst cycles,#CYC_V
	ldrsb r0,[m6502_pc],#1
	addeq m6502_pc,m6502_pc,r0
;	subeq cycles,cycles,#3*CYCLE
	subeq cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_51;   EOR ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opEOR
	fetch 5
;----------------------------------------------------------------------------
_55;   EOR $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opEOR
	fetch 4
;----------------------------------------------------------------------------
_56;   LSR $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opLSR
	fetch_c 6
;----------------------------------------------------------------------------
_58;   CLI
;----------------------------------------------------------------------------
	bic cycles,cycles,#CYC_I
	fetch 2
;----------------------------------------------------------------------------
_59;   EOR $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opEOR
	fetch 4
;----------------------------------------------------------------------------
_5D;   EOR $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opEOR
	fetch 4
;----------------------------------------------------------------------------
_5E;   LSR $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opLSR
	fetch_c 7
;----------------------------------------------------------------------------
_60;   RTS
;----------------------------------------------------------------------------
	pop16
	add m6502_pc,m6502_pc,#1
	encodePC
	fetch 6
;----------------------------------------------------------------------------
_61;   ADC ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opADC
	fetch_c 6
;----------------------------------------------------------------------------
_65;   ADC $nn
;----------------------------------------------------------------------------
	doZ
	opADC
	fetch_c 3
;----------------------------------------------------------------------------
_66;   ROR $nn
;----------------------------------------------------------------------------
	doZ
	opROR
	fetch 5
;----------------------------------------------------------------------------
_68;   PLA
;----------------------------------------------------------------------------
	pop8 m6502_nz
	mov m6502_a,m6502_nz,lsl#24
	fetch 4
;----------------------------------------------------------------------------
_69;   ADC #$nn
;----------------------------------------------------------------------------
	doIMM
	opADC
	fetch_c 2
;----------------------------------------------------------------------------
_6A;   ROR
;----------------------------------------------------------------------------
	movs cycles,cycles,lsr#1		;get C
	mov m6502_a,m6502_a,rrx
	movs m6502_nz,m6502_a,asr#24	;NZ
	and m6502_a,m6502_a,#0xff000000
	adc cycles,cycles,cycles		;Set C
	fetch 2
;----------------------------------------------------------------------------
_6C;   JMP ($nnnn)	JMP ($data16) 间接寻址 *********************************
;----------------------------------------------------------------------------		
	doABS       
	adr r1,memmap_tbl			   
	and r2,addy,#0xE000	;		  
;	ldr r1,[r1,r2,lsr#11]  		  ;>>11 addr&0x7FF
	lsr r0,r2,#11			  
	ldr r1,[r1,r0]		   ;在数据传送之前,将偏移量加到Rn 中,其结果作为传送数据的存储地址
							   
	ldrb m6502_pc,[r1,addy]     ;//若使用后缀"!",则结果写回到Rn中
	add r1,r1,addy	    

	ldrb r0,[r1,#1]	    
	orr m6502_pc,m6502_pc,r0,lsl#8	 ;m6502_pc=r9使用ORR 指令将近R9的高8 位数据移入到R0低8位
	encodePC	
	fetch 5
;----------------------------------------------------------------------------
_6D;   ADC $nnnn
;----------------------------------------------------------------------------
	doABS
	opADC
	fetch_c 4
;----------------------------------------------------------------------------
_6E;   ROR $nnnn
;----------------------------------------------------------------------------
	doABS
	opROR
	fetch 6
;----------------------------------------------------------------------------
_70;   BVS *
;----------------------------------------------------------------------------
	tst cycles,#CYC_V
	ldrsb r0,[m6502_pc],#1
	addne m6502_pc,m6502_pc,r0
;	subne cycles,cycles,#3*CYCLE
	subne cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_71;   ADC ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opADC
	fetch_c 5
;----------------------------------------------------------------------------
_75;   ADC $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opADC
	fetch_c 4
;----------------------------------------------------------------------------
_76;   ROR $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opROR
	fetch 6
;----------------------------------------------------------------------------
_78;   SEI
;----------------------------------------------------------------------------
	orr cycles,cycles,#CYC_I
	fetch 2
;----------------------------------------------------------------------------
_79;   ADC $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opADC
	fetch_c 4
;----------------------------------------------------------------------------
_7D;   ADC $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opADC
	fetch_c 4
;----------------------------------------------------------------------------
_7E;   ROR $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opROR
	fetch 7
;----------------------------------------------------------------------------
_81;   STA ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opSTORE m6502_a
	fetch 6
;----------------------------------------------------------------------------
_84;   STY $nn
;----------------------------------------------------------------------------
	doZ
	opSTORE m6502_y
	fetch 3
;----------------------------------------------------------------------------
_85;   STA $nn
;----------------------------------------------------------------------------
	doZ
	opSTORE m6502_a
	fetch 3
;----------------------------------------------------------------------------
_86;   STX $nn
;----------------------------------------------------------------------------
	doZ
	opSTORE m6502_x
	fetch 3
;----------------------------------------------------------------------------
_88;   DEY
;----------------------------------------------------------------------------
	sub m6502_y,m6502_y,#0x01000000
	mov m6502_nz,m6502_y,asr#24
	fetch 2
;----------------------------------------------------------------------------
_8A;   TXA
;----------------------------------------------------------------------------
	mov m6502_a,m6502_x
	mov m6502_nz,m6502_x,asr#24
	fetch 2
;----------------------------------------------------------------------------
_8C;   STY $nnnn
;----------------------------------------------------------------------------
	doABS
	opSTORE m6502_y
	fetch 4
;----------------------------------------------------------------------------
_8D;   STA $nnnn
;----------------------------------------------------------------------------
	doABS
	opSTORE m6502_a	  
	fetch 4
;----------------------------------------------------------------------------
_8E;   STX $nnnn
;----------------------------------------------------------------------------
	doABS
	opSTORE m6502_x
	fetch 4
;----------------------------------------------------------------------------
_90;   BCC *
;----------------------------------------------------------------------------
	tst cycles,#CYC_C			;Test Carry
	ldrsb r0,[m6502_pc],#1
	addeq m6502_pc,m6502_pc,r0
;	subeq cycles,cycles,#3*CYCLE
	subeq cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_91;   STA ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opSTORE m6502_a
	fetch 6
;----------------------------------------------------------------------------
_94;   STY $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opSTORE m6502_y
	fetch 4
;----------------------------------------------------------------------------
_95;   STA $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opSTORE m6502_a
	fetch 4
;----------------------------------------------------------------------------
_96;   STX $nn,Y
;----------------------------------------------------------------------------
	doZIYf
	opSTORE m6502_x
	fetch 4
;----------------------------------------------------------------------------
_98;   TYA
;----------------------------------------------------------------------------
	mov m6502_a,m6502_y
	mov m6502_nz,m6502_y,asr#24
	fetch 2
;----------------------------------------------------------------------------
_99;   STA $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opSTORE m6502_a
	fetch 5
;----------------------------------------------------------------------------
_9A;   TXS
;----------------------------------------------------------------------------
	mov r0,m6502_x,lsr#24
	strb r0,m6502_s
	fetch 2
;----------------------------------------------------------------------------
_9D;   STA $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opSTORE m6502_a
	fetch 5
;----------------------------------------------------------------------------
_A0;   LDY #$nn
;----------------------------------------------------------------------------
	doIMM
	opLOAD m6502_y
	fetch 2
;----------------------------------------------------------------------------
_A1;   LDA ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opLOAD m6502_a
	fetch 6
;----------------------------------------------------------------------------
_A2;   LDX #$nn
;----------------------------------------------------------------------------
	doIMM
	opLOAD m6502_x
	fetch 2
;----------------------------------------------------------------------------
_A4;   LDY $nn
;----------------------------------------------------------------------------
	doZ
	opLOAD m6502_y
	fetch 3
;----------------------------------------------------------------------------
_A5;   LDA $nn
;----------------------------------------------------------------------------
	doZ
	opLOAD m6502_a
	fetch 3
;----------------------------------------------------------------------------
_A6;   LDX $nn
;----------------------------------------------------------------------------
	doZ
	opLOAD m6502_x
	fetch 3
;----------------------------------------------------------------------------
_A8;   TAY
;----------------------------------------------------------------------------
	mov m6502_y,m6502_a
	mov m6502_nz,m6502_y,asr#24
	fetch 2
;----------------------------------------------------------------------------
_A9;   LDA #$nn
;----------------------------------------------------------------------------
	doIMM
	opLOAD m6502_a
	fetch 2
;----------------------------------------------------------------------------
_AA;   TAX
;----------------------------------------------------------------------------
	mov m6502_x,m6502_a
	mov m6502_nz,m6502_x,asr#24
	fetch 2
;----------------------------------------------------------------------------
_AC;   LDY $nnnn
;----------------------------------------------------------------------------
	doABS
	opLOAD m6502_y
	fetch 4
;----------------------------------------------------------------------------
_AD;   LDA $nnnn
;----------------------------------------------------------------------------
	doABS
	opLOAD m6502_a
	fetch 4
;----------------------------------------------------------------------------
_AE;   LDX $nnnn
;----------------------------------------------------------------------------
	doABS
	opLOAD m6502_x
	fetch 4
;----------------------------------------------------------------------------
_B0;   BCS *
;----------------------------------------------------------------------------
	tst cycles,#CYC_C			;Test Carry
	ldrsb r0,[m6502_pc],#1
	addne m6502_pc,m6502_pc,r0
;	subne cycles,cycles,#3*CYCLE
	subne cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_B1;   LDA ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opLOAD m6502_a
	fetch 5
;----------------------------------------------------------------------------
_B4;   LDY $nn,X
;----------------------------------------------------------------------------
	doZIX
	opLOAD m6502_y
	fetch 4
;----------------------------------------------------------------------------
_B5;   LDA $nn,X
;----------------------------------------------------------------------------
	doZIX
	opLOAD m6502_a
	fetch 4
;----------------------------------------------------------------------------
_B6;   LDX $nn,Y
;----------------------------------------------------------------------------
	doZIY
	opLOAD m6502_x
	fetch 4
;----------------------------------------------------------------------------
_B8;   CLV
;----------------------------------------------------------------------------
	bic cycles,cycles,#CYC_V
	fetch 2
;----------------------------------------------------------------------------
_B9;   LDA $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opLOAD m6502_a
	fetch 4
;----------------------------------------------------------------------------
_BA;   TSX
;----------------------------------------------------------------------------
	ldrb m6502_x,m6502_s
	mov m6502_x,m6502_x,lsl#24
	mov m6502_nz,m6502_x,asr#24
	fetch 2
;----------------------------------------------------------------------------
_BC;   LDY $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opLOAD m6502_y
	fetch 4
;----------------------------------------------------------------------------
_BD;   LDA $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opLOAD m6502_a
	fetch 4
;----------------------------------------------------------------------------
_BE;   LDX $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opLOAD m6502_x
	fetch 4
;----------------------------------------------------------------------------
_C0;   CPY #$nn
;----------------------------------------------------------------------------
	doIMM
	opCOMP m6502_y
	fetch_c 2
;----------------------------------------------------------------------------
_C1;   CMP ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opCOMP m6502_a
	fetch_c 6
;----------------------------------------------------------------------------
_C4;   CPY $nn
;----------------------------------------------------------------------------
	doZ
	opCOMP m6502_y
	fetch_c 3
;----------------------------------------------------------------------------
_C5;   CMP $nn
;----------------------------------------------------------------------------
	doZ
	opCOMP m6502_a
	fetch_c 3
;----------------------------------------------------------------------------
_C6;   DEC $nn
;----------------------------------------------------------------------------
	doZ
	opDEC
	fetch 5
;----------------------------------------------------------------------------
_C8;   INY
;----------------------------------------------------------------------------
	add m6502_y,m6502_y,#0x01000000
	mov m6502_nz,m6502_y,asr#24
	fetch 2
;----------------------------------------------------------------------------
_C9;   CMP #$nn
;----------------------------------------------------------------------------
	doIMM
	opCOMP m6502_a
	fetch_c 2
;----------------------------------------------------------------------------
_CA;   DEX
;----------------------------------------------------------------------------
	sub m6502_x,m6502_x,#0x01000000
	mov m6502_nz,m6502_x,asr#24
	fetch 2
;----------------------------------------------------------------------------
_CC;   CPY $nnnn
;----------------------------------------------------------------------------
	doABS
	opCOMP m6502_y
	fetch_c 4
;----------------------------------------------------------------------------
_CD;   CMP $nnnn
;----------------------------------------------------------------------------
	doABS
	opCOMP m6502_a
	fetch_c 4
;----------------------------------------------------------------------------
_CE;   DEC $nnnn
;----------------------------------------------------------------------------
	doABS
	opDEC
	fetch 6
;----------------------------------------------------------------------------
_D0;   BNE *
;----------------------------------------------------------------------------
	tst m6502_nz,#0xff
	ldrsb r0,[m6502_pc],#1
	addne m6502_pc,m6502_pc,r0
;	subne cycles,cycles,#3*CYCLE
	subne cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_D1;   CMP ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opCOMP m6502_a
	fetch_c 5
;----------------------------------------------------------------------------
_D5;   CMP $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opCOMP m6502_a
	fetch_c 4
;----------------------------------------------------------------------------
_D6;   DEC $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opDEC
	fetch 6
;----------------------------------------------------------------------------
_D8;   CLD
;----------------------------------------------------------------------------
	bic cycles,cycles,#CYC_D
	fetch 2
;----------------------------------------------------------------------------
_D9;   CMP $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opCOMP m6502_a
	fetch_c 4
;----------------------------------------------------------------------------
_DD;   CMP $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opCOMP m6502_a
	fetch_c 4
;----------------------------------------------------------------------------
_DE;   DEC $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opDEC
	fetch 7
;----------------------------------------------------------------------------
_E0;   CPX #$nn
;----------------------------------------------------------------------------
	doIMM
	opCOMP m6502_x
	fetch_c 2
;----------------------------------------------------------------------------
_E1;   SBC ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opSBC
	fetch_c 6
;----------------------------------------------------------------------------
_E4;   CPX $nn
;----------------------------------------------------------------------------
	doZ
	opCOMP m6502_x
	fetch_c 3
;----------------------------------------------------------------------------
_E5;   SBC $nn
;----------------------------------------------------------------------------
	doZ
	opSBC
	fetch_c 3
;----------------------------------------------------------------------------
_E6;   INC $nn
;----------------------------------------------------------------------------
	doZ
	opINC
	fetch 5
;----------------------------------------------------------------------------
_E8;   INX
;----------------------------------------------------------------------------
	add m6502_x,m6502_x,#0x01000000
	mov m6502_nz,m6502_x,asr#24
	fetch 2
;----------------------------------------------------------------------------
_E9;   SBC #$nn
;----------------------------------------------------------------------------
	doIMM
	opSBC
	fetch_c 2
;----------------------------------------------------------------------------
_EA;   NOP
;----------------------------------------------------------------------------
	fetch 2
;----------------------------------------------------------------------------
_EC;   CPX $nnnn
;----------------------------------------------------------------------------
	doABS
	opCOMP m6502_x
	fetch_c 4
;----------------------------------------------------------------------------
_ED;   SBC $nnnn
;----------------------------------------------------------------------------
	doABS
	opSBC
	fetch_c 4
;----------------------------------------------------------------------------
_EE;   INC $nnnn
;----------------------------------------------------------------------------
	doABS
	opINC
	fetch 6
;----------------------------------------------------------------------------
_F0;   BEQ *
;----------------------------------------------------------------------------
	tst m6502_nz,#0xff
	ldrsb r0,[m6502_pc],#1
	addeq m6502_pc,m6502_pc,r0
;	subeq cycles,cycles,#3*CYCLE
	subeq cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_F1;   SBC ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opSBC
	fetch_c 5
;----------------------------------------------------------------------------
_F5;   SBC $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opSBC
	fetch_c 4
;----------------------------------------------------------------------------
_F6;   INC $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opINC
	fetch 6
;----------------------------------------------------------------------------
_F8;   SED
;----------------------------------------------------------------------------
	orr cycles,cycles,#CYC_D
	fetch 2
;----------------------------------------------------------------------------
_F9;   SBC $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opSBC
	fetch_c 4
;----------------------------------------------------------------------------
_FD;   SBC $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opSBC
	fetch_c 4
;----------------------------------------------------------------------------
_FE;   INC $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opINC
	fetch 7
;***********************************************************以下指令是一些HACK游戏需要******************
_FF;  ISB $????,X  加的，不确定正确    激龟忍者传2无敌HACK需要
;-------------------------------------------------------------------
	doAIX		;MR_AX();
	opSBC	    ;ISB(); 
                ;MW_EA();  #define	MW_EA()		WR6502(EA,DT)  // EA .... EFFECTIVE ADDRESS
	fetch 5	    ;ADD_CYCLE(5);                                  // DT .... DATA
;------------------------------------------------------------------------
_FB;  ISB $????,X  加的，不确定正确    激龟忍者传2无敌HACK需要
;-------------------------------------------------------------------
	doAIY		;MR_AY();
	opSBC	    ;ISB(); 
                ;MW_EA();  
	fetch 5	    ;ADD_CYCLE(5);                                  
;------------------------------------------------------------------------
_14;      加的，不确定正确          激龟忍者传2无敌HACK需要
;-------------------------------------------------------------------
	add m6502_pc,m6502_pc,#1  ;R.PC++;
	fetch 4	                  ;ADD_CYCLE(4);                           
;-------------------------------------------------------------------
_67; // RRA $??                 帝国战机无敌HACK需要
;-------------------------------------------------------------------
	doZ			    ;MR_ZP(); 
	opADC           ;RRA(); 
					;MW_ZP();
	fetch 5 	    ;ADD_CYCLE(5);				
;--------------------------------------------------------------------
_03; // SLO ($??,X)              帝国战机无敌HACK需要
;-------------------------------------------------------------------
	doIIX		;MR_IX(); 
				;SLO(); 
				;MW_EA();
	fetch 8;	;ADD_CYCLE(8);
;-----------------------------------------------------------------
_07; // SLO $??
;------------------------------------------------------------------
	doZ		    ;MR_ZP(); 
				;SLO(); 
				;MW_ZP();
	fetch 5		;ADD_CYCLE(5);

;----------------------------------------------------------------------------
	IMPORT debug_6502  ;main.c
_xx;	???					;invalid opcode	无效的操作码
;----------------------------------------------------------------------------
	mov r1,#1           ;不用debug可以直接注译这两行
    bl debug_6502
	
	fetch 2

;***************************************************************************************************

 AREA rom_code, CODE, READONLY
;	THUMB
   PRESERVE8 
	
;----------------------------------------------------------------------------
cpu6502_init PROC
;----------------------------------------------------------------------------
	stmfd sp!,{r4-r11,lr}
		
    ldr r10,=cpu_data	;读取地址
	ldr r11,=NES_RAM	;r11=cpu_zpage
	
        ldr r11,[r11]       ;NES_RAM用了指针 
;*******************************************************		
		str r11,memmap_tbl             ;NES_RAM用了指针
		str r11,memmap_tbl+4
		str r11,memmap_tbl+8
  
		ldr r0,=NES_SRAM              ;NES_SRAM用了指针
		ldr r0,[r0]
		str r0,memmap_tbl+12
;**********************************************************************			

	ldr r0,=romfile		 
	ldr r0,[r0]			 ;R0现在指向ROM映像（包括头）
	add r3,r0,#16		;r3现在指向rom镜像(不包括头）
	str r3,rombase		;设置rom基地址
						;r3=rombase til end of loadcart so DON'T FUCK IT UP
	mov r2,#1
	ldrb r1,[r3,#-12]	; 16kB PROM的数目  	 2
	rsb r0,r2,r1,lsl#14	 ;romsize=X*16KB	 <<14 逆向减法指令	 r0=0x7fff
	str r0,rommask		;rommask=promsize-1	 32768-1	
;------------------------------------------------------------------------------------	
	mov r9,#0		;(消除任何encodePC的映射器*初始化过程中的错误)
	str r9,lastbank		;6502PC从 ROM的最后偏移量写0

	mov r0,#0			;默认rom映射
	bl map89AB_			;89AB=1st 16k
	mov r0,#-1
	bl mapCDEF_			;CDEF=last 16k
		
;------------------------------------------------------------------------------
    ldrb r1,[r3,#-10]		;get mapper#
	ldrb r2,[r3,#-9]
	tst r2,#0x0e			;long live DiskDude!
	and r1,r1,#0xf0
	and r2,r2,#0xf0
	orr r0,r2,r1,lsr#4
	movne r0,r1,lsr#4		;ignore high nibble if header looks bad	忽略高四位，如果头看起来很糟糕
                            ;r0=mapper号
;--------------------------------------------------------------------------------	
		
	ldr r0,=Mapper_W           ;保存处理mapper的函数地址
	str r0,writemem_tbl+16
	str r0,writemem_tbl+20
	str r0,writemem_tbl+24
	str r0,writemem_tbl+28

;-------------------------------------------------------------------------------
	bl CPU_reset		;reset everything else
	ldmfd sp!,{r4-r11,lr}
	bx lr
	ENDP

;----------------------------------------------------------------------------
map67_0	;mapper3 r0=page# ;6502.s俄罗斯方块需要
;----------------------------------------------------------------------------
	ldr r10,=cpu_data	;读取地址
	mov r9,#0		;(消除任何encodePC的映射器*初始化过程中的错误)
	str r9,lastbank		;6502PC从 ROM的最后偏移量写0
map67_	
	ldr r1,rommask
	and r0,r1,r0,lsl#13
	ldr r1,rombase
	add r0,r1,r0
	sub r0,r0,#0x6000
	str r0,memmap_tbl+12
	b flush
;----------------------------------------------------------------------------
map89_	;rom paging.. r0=page# ROM分页
;----------------------------------------------------------------------------
	ldr r1,rombase			 ;rom开始地址
	sub r1,r1,#0x8000
	ldr r2,rommask
	and r0,r2,r0,lsl#13
	add r0,r1,r0
	str r0,memmap_tbl+16
	b flush
;----------------------------------------------------------------------------
mapAB_
;----------------------------------------------------------------------------
	ldr r1,rombase
	sub r1,r1,#0xa000
	ldr r2,rommask
	and r0,r2,r0,lsl#13
	add r0,r1,r0
	str r0,memmap_tbl+20
	b flush
;----------------------------------------------------------------------------
mapCD_
;----------------------------------------------------------------------------
	ldr r1,rombase
	sub r1,r1,#0xc000
	ldr r2,rommask
	and r0,r2,r0,lsl#13
	add r0,r1,r0
	str r0,memmap_tbl+24
	b flush
;----------------------------------------------------------------------------
mapEF_
;----------------------------------------------------------------------------
	ldr r1,rombase
	sub r1,r1,#0xe000
	ldr r2,rommask
	and r0,r2,r0,lsl#13
	add r0,r1,r0
	str r0,memmap_tbl+28
	b flush
;----------------------------------------------------------------------------
map89AB_
;----------------------------------------------------------------------------
	ldr r1,rombase		   ;rom基地址（不包括头）
	sub r1,r1,#0x8000
	ldr r2,rommask
	and r0,r2,r0,lsl#14
	add r0,r1,r0
	str r0,memmap_tbl+16
	str r0,memmap_tbl+20
flush		;update m6502_pc & lastbank
	ldr r1,lastbank
	sub r9,r9,r1
	and r1,r9,#0xE000	   ;//r9和0xe000按位与运算
	adr r2,memmap_tbl		   ;//把存储器映象地址加载到r2
	lsr r1,r1,#11				;//>>11位	  r1/2048
	ldr r0,[r2,r1]				;//读取r2地址+r1偏移的数据到r0

	str r0,lastbank				;//保存6502PC从 ROM的最后偏移量 
	add r9,r9,r0	;//m6502_pc+r0
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr

;----------------------------------------------------------------------------
mapCDEF_
;----------------------------------------------------------------------------
	ldr r1,rombase
	sub r1,r1,#0xc000
	ldr r2,rommask
	and r0,r2,r0,lsl#14
	add r0,r1,r0
	str r0,memmap_tbl+24
	str r0,memmap_tbl+28
	b flush
;----------------------------------------------------------------------------
map89ABCDEF_           ;mapper9
;----------------------------------------------------------------------------
	ldr r10,=cpu_data	;读取地址
	mov r9,#0		;(消除任何encodePC的映射器*初始化过程中的错误)
	str r9,lastbank		;6502PC从 ROM的最后偏移量写0
	
	ldr r1,rombase
	sub r1,r1,#0x8000
	ldr r2,rommask
	and r0,r2,r0,lsl#15
	add r0,r1,r0
	str r0,memmap_tbl+16
	str r0,memmap_tbl+20
	str r0,memmap_tbl+24
	str r0,memmap_tbl+28
	b flush
	
;*************************************************************************************
     IMPORT asm_Mapper_Write;
Mapper_W	
;-------------------------------------------
	stmfd sp!,{r3,lr}	;LR 寄存器放栈
	mov r1,r12
	bl asm_Mapper_Write
	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
	nop
;---------------------------------------------------------------------------------------

;*****************************************************************************************************

	AREA cpu_run, CODE, READONLY
run6502	PROC;r0=要运行的cpu周期*256
;----------------------------------------------------------------------------
	
	stmfd sp!,{r4-r11,lr}		;将这几个寄存器中的值保存到堆栈中
	
	ldr globalptr,=cpu_data	 ;r10   wram_globals: 读取地址
	ldr cpu_zpage,=NES_RAM			   	;r11
        ldr cpu_zpage,[cpu_zpage]       ;NES_RAM用了指针
 
	adr r1,cpuregs
	ldmia r1,{m6502_nz-m6502_pc}	;restore 6502 state恢复6502状态	 r3-r9	
	add cycles,cycles,r0	
			
	ldrb r0,cpuirqf ;cpu中断标志
	cmp r0,#0x01;
	beq CheckI      ;EQ       相等(EQual)	irq6502;

	fetch 0       ;//提取操作码并运行							   
exit_run

    ldrb r0,cpunmif ;cpu中断标志
	cmp r0,#0x01;
	beq NMI6502      ;EQ       相等(EQual)	
	
exit_nmi	
	adr r0,cpuregs
	stmia r0,{m6502_nz-m6502_pc} ;保存6502状态	  r3-r9
	
	ldmfd sp!,{r4-r11,pc}	;exit 					
    ENDP
;***************************************************************************************
NMI6502 PROC;---------------------------
    mov r0,#0
	str r0,cpunmif;清除cpu中断标志   

	ldr r12,=NMI_VECTOR		 ;NMI?	 addy
	bl Vec6502
	sub cycles,cycles,#7*256	;CYCLE=256	 6502的中断潜伏期为七 (7) 个周
                              ; 期; 这也就是说需要需要七 (7) 个周期来移入和移出一个中断
    b exit_nmi		;return 
	ENDP
;----------------------------------------------------------------------------

default_scanlinehook
   
	fetch 0
;----------------------------------------------------------
CheckI								;Check Interrupt Disable 检查中断禁用
;----------------------------------------------------------
	tst cycles,#CYC_I
	bne default_scanlinehook		;we dont want no stinkin irqs 我们不需要没有讨厌的IRQ
;----------------------------------------------------------
irq6502  
;----------------------------------------------------------
	mov r0,#0
	str r0,cpuirqf;清除cpu中断标志
	
	ldr r12,=IRQ_VECTOR
	bl Vec6502
	fetch 7    
;----------------------------------------------------------
Vec6502
;----------------------------------------------------------
	ldr r0,lastbank
	sub r0,m6502_pc,r0
	push16					;save PC

	encodeP (R)				;save P
VecCont
	push8 r0

	orr cycles,cycles,#CYC_I	;disable IRQ	禁用IRQ

	ldr r0,memmap_tbl+28	  ;7*4
;	ldrb m6502_pc,[r0,r12]!
	ldrb m6502_pc,[r0,r12]	;在数据传送之前,将偏移量加到Rn 中,其结果作为传送数据的存储地址
                            ;若使用后缀"!",则结果写回到Rn中
	add r0,r0,r12			 ;R12=0xfffc ;// 复位中断向量地址
	
	ldrb r2,[r0,#1]
	orr m6502_pc,m6502_pc,r2,lsl#8
	encodePC				;get IRQ vector得到6502 PC ROM的偏移量

	bx lr					  ; 函数返回
;----------------------------------------------------------------------------
CPU_reset PROC	;called by loadcart (r0-r9 are free to use)
;----------------------------------------------------------------------------
	str lr,[sp,#-4]!	
	
	mov m6502_a,#0
	mov m6502_x,#0
	mov m6502_y,#0
	mov m6502_nz,#0
	adr m6502_rmem,readmem_tbl ;把readmem_tbl的地址加载到m6502_rmem
	
;	ldr r0,=NES_RAM+0x100	   ;256	
		  ldr r0,=NES_RAM            ;NES_RAM用了指针
		  ldr r0,[r0]                ;
		  add r0,#0x100
  
	str r0,m6502_s		;S=0xFD (0x100-3)	  把一个寄存器按字存储到存储器中
;-------------------------------------------------------	
	mov r0,#0
	str r0,cpunmif  ;清除cpu中断标志
	str r0,cpuirqf  ;清除cpu中断标志
;------------------------------------------	
	mov cycles,#0		;D=0, C=0, V=0, I=1 disable IRQ.

	ldr r12,=RES_VECTOR		 ;// 复位中断向量地址
	bl Vec6502

	adr r0,cpuregs			 ;读取地址
	stmia r0,{m6502_nz-m6502_pc}	   ;保存6502状态

	ldr r1,=exit_run				  ;
	str r1,nexttimeout		  ;保存指令执行完后下一步的PC地址

	ldr pc,[sp],#4
	ENDP
;	nop
;-------------------------------------------------------------------------

   AREA rwram_code, CODE, READONLY;READWRITE**************************************
;----------------------------------------------------------------------------
;memory
;------------------------------------------------------------------------
empty_R		;读地址不正确read bad address (error)
;----------------------------------------------------------------------------	
	mov r0,r12
	mov r1,#2
    bl debug_6502
	;----------------------------------
	mov r0,#0
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr  
;----------------------------------------------------------------------------
void PROC;- - - - - - - - -空函数
	mov r0,#0	
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
	ENDP
;----------------------------------------------------------------------------
ram_R	;ram read ($0000-$1FFF)
;----------------------------------------------------------------------------
	bic addy,addy,#0x1f800		;only 0x07FF is RAM
	ldrb r0,[cpu_zpage,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
ram_W	;ram write ($0000-$1FFF)
;----------------------------------------------------------------------------
	bic addy,addy,#0x1f800		;only 0x07FF is RAM
	strb r0,[cpu_zpage,addy]   ; cpu_zpage	RN r11 ;=CPU_RAM
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
sram_R	;sram read ($6000-$7FFF)
;----------------------------------------------------------------------------
	sub r1,addy,#0x6000	
    ldr r2,memmap_tbl+12 
;	ldrb r0,[cpu_zpage,r1]
	ldrb r0,[r2,r1]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
sram_W	;sram write ($6000-$7FFF)
;----------------------------------------------------------------------------
	sub addy,addy,#0x6000
    ldr r1,memmap_tbl+12                     
;	strb r0,[cpu_zpage,addy]
	strb r0,[r1,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
rom_R60	;rom read ($6000-$7FFF)
;----------------------------------------------------------------------------
	ldr r1,memmap_tbl+12
	ldrb r0,[r1,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
rom_R80	;rom read ($8000-$9FFF)
;----------------------------------------------------------------------------
	ldr r1,memmap_tbl+16
	ldrb r0,[r1,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
rom_RA0	;rom read ($A000-$BFFF)
;----------------------------------------------------------------------------
	ldr r1,memmap_tbl+20
	ldrb r0,[r1,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
rom_RC0	;rom read ($C000-$DFFF)
;----------------------------------------------------------------------------
	ldr r1,memmap_tbl+24
	ldrb r0,[r1,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
rom_RE0	;rom read ($E000-$FFFF)
;----------------------------------------------------------------------------
	ldr r1,memmap_tbl+28
	ldrb r0,[r1,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr

	nop
;----------------------------------------------------------------------------
;IO
   AREA io_code, CODE, READONLY ;--
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
IO_R		;I/O read
;----------------------------------------------------------------------------
	mov r2,#0x4018      ;$4018-$6000
	cmp r12,r2    	
	bhi  Read_Low              ;HI  无符号数大于  C==1 && Z==0 
		
	sub r1,r12,#0x4000	 ;addy=r12
	subs r1,r1,#0x15
	bmi empty_R		  ;读地址不正确 MI       负数(MInus)                   N==1 
	cmp r1,#3
;	ldrmi pc,[pc,r2,lsl#2]
	ldr r2,=io_read_tbl   ;//改过，加3行
	add r2,r2,r1,lsl#2			  ;<<2
	ldrmi pc,[r2]
	b empty_R          ;读地址不正确
;	nop
	
io_read_tbl
	DCD apu_4015R;void;_4015r	;4015 (sound)
	DCD joy0_R	;4016: controller 1
	DCD joy1_R	;4017: controller 2
;----------------------------------------------------------------------------
IO_W		;I/O write
;----------------------------------------------------------------------------
	mov r2,#0x4018      ;$4018-$6000
	cmp r12,r2    	
	bhi  Write_Low              ;HI  无符号数大于  C==1 && Z==0 
	
	sub r1,r12,#0x4000	   ;addy=r12
	cmp r1,#0x18
;	ldrmi pc,[pc,r2,lsl#2]
	ldr r2,=io_write_tbl   ;//改过，加3行
	add r2,r2,r1,lsl#2			  ;<<2		
	ldrmi pc,[r2]          ;//直接操作pc太他妈危险了
	b empty_R		  ;读地址不正确
 	nop
	
io_write_tbl	
	DCD apu_w;void;_4000w
	DCD apu_w;_4001w
	DCD apu_w;_4002w
	DCD apu_w;_4003w
	DCD apu_w;_4004w
	DCD apu_w;_4005w
	DCD apu_w;_4006w
	DCD apu_w;_4007w
	DCD apu_w;_4008w
	DCD apu_w;void;
	DCD apu_w;_400aw
	DCD apu_w;void;_400bw
	DCD apu_w;void;_400cw
	DCD apu_w;void
	DCD apu_w;void;_400ew
	DCD apu_w;void;_400fw
	DCD apu_w;void;_4010w
	DCD apu_w;void;_4011w
	DCD apu_w;void;_4012w
	DCD apu_w;void;_4013w
	DCD dma_W	;$4014: Sprite DMA transfer
	DCD apu_4015w;void;_4015w		 ; 声音通道切换 

	DCD joy0_W	;$4016: Joypad 0 write;joypad_write_ptr
	DCD void;apu_4017w;void;$4017: ?
		
;-------------------------------------------------------------------------------
    IMPORT asm_Mapper_ReadLow
Read_Low  PROC;$5000-$6000  mapper->MemoryReadLow(addr);	
;------------------------------------------------------------------------------
    stmfd sp!,{r3,lr}	;LR 寄存器放栈 
	mov r0,r12
	bl asm_Mapper_ReadLow

	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
	ENDP
;-------------------------------------------------------------------------------
    IMPORT asm_Mapper_WriteLow
Write_Low  PROC;$5000-$6000  mapper->MemoryWriteLow( data, addr);	
;------------------------------------------------------------------------------
    stmfd sp!,{r3,lr}	;LR 寄存器放栈 
	mov r1,r12
	bl asm_Mapper_WriteLow

	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
	ENDP
;-----------------------------------------------------------------------------
	IMPORT Apu_Write  ;apu.c 
	IMPORT Apu_Write4015  ;apu.c	
;-----------------------------------------------------------------------------------
apu_w					; 0x4000--0x4013
;---------------------------------------------------------------------------------
    stmfd sp!,{r3,lr}	;LR 寄存器放栈 
	bl Apu_Write

	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;-----------------------------------------------------------------------------------
apu_4015w
;-------------------------------------------------------------------------
	stmfd sp!,{r3,lr}	;LR 寄存器放栈      
	bl Apu_Write4015
	
	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;-----------------------------------------------------------------------------------
	IMPORT Apu_Write4017  ;apu.c
apu_4017w
;-------------------------------------------------------------------------
	stmfd sp!,{r3,lr}	;LR 寄存器放栈      
	bl Apu_Write4017
	
	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
    IMPORT Apu_Read4015  ;apu.c
apu_4015R	;4015
;----------------------------------------------------------------------------------	
	stmfd sp!,{r3,lr}	;LR 寄存器放栈 
	add r0,r1,#0x15
	bl Apu_Read4015
	
	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
dma_W	;(4014)		sprite DMA transfer	精灵DMA传输	DMA访问精灵RAM：
;通过写一个值xx到这个端口，引起CPU内存地址为$xx00－$xxFF的区域传送到精灵内存 
;----------------------------------------------------------------------------
	sub cycles,cycles,#512*256
	stmfd sp!,{r3,lr}

	and r1,r0,#0xe0
	adr r2,memmap_tbl  ;CPU_RAM	
	lsr r1,r1,#3       ;>>3
	ldr r2,[r2,r1]
	and r0,r0,#0xff
	add r2,r2,r0,lsl#8	;addy  r2=DMA source 源
	ldr r1,=spr_ram		;r1     DMA的 目的地	   ppu.c
		ldr r1,[r1]         ;spr_ram用了指针
		
	mov r0,#64			;256/4
copy_
	subs r0,r0,#1		  ;-1
	ldr r3,[r2,r0,lsl#2]
	str r3,[r1,r0,lsl#2]  ;<<2	   *4
	bne copy_              ;r0!=0

	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
    bx lr
;----------------------------------------------------------------------------
    IMPORT PADdata0
	IMPORT PADdata1	
joy0_W		;4016  手柄1键值 [7:0]右7 左6 下5 上4 Start3 Select2 B1 A0   )
;----------------------------------------------------------------------------
	tst r0,#1           ;0＝写，1＝读
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bxne lr            ;NE       不等（NotEqual）  
	
	ldr r1,=PADdata0;   //手柄1键值  
    ldr r1,[r1]
	str r1,joy0data
	          	
	ldr r1,=PADdata1;   //手柄1键值  
    ldr r1,[r1]
	str r1,joy1data							
				
	bx lr
;----------------------------------------------------------------------------
joy0_R		;4016
;----------------------------------------------------------------------------	
	ldr r0,joy0data	   ;串行数据  当前读取位;joy0data是键值
    mov r1,r0,lsr#1       ;>>1
	str r1,joy0data
	
	and r0,r0,#1      ;&1	
	orr r0,r0,#0x40   ;|0x40

    orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
joy1_R		;4017
;----------------------------------------------------------------------------
	ldr r0,joy1data	   ;串行数据  当前读取位;joy0data是键值
    mov r1,r0,lsr#1       ;>>1
	str r1,joy1data
	
	and r0,r0,#1      ;&1	
	orr r0,r0,#0x40   
	
    orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;--------------------------------------------------------------
K6502_Read	PROC;apu  Rendering DPCM channel #5		r0=APU->ApuC5Address不确定正确*
;---------------------------------------------------------------
	   EXPORT  K6502_Read		;switch ( wAddr & 0xe000 ) apu.c
    stmfd sp!,{lr}
	
	mov r1,r0,lsr#13 ;>>13=  & 0xe000
	ldr r2,=CPU_RAM;;//存储器映象 ram+rom	
	ldr r1,[r2,r1,lsl#2]	;lookup rom ptr..查找ptr
	
    bic r0,r0,#0xe000 ;and r0,#0x1fff &0x1fff	
	ldrb r0,[r1,r0]
	
    ldmfd sp!,{lr}
	bx lr
	ENDP
;	nop
;------------------------------------------------------------------------
	 AREA CPU_GPU, CODE, READONLY
	  
    IMPORT PPU_WriteToPort    ;PPU.c
	IMPORT PPU_ReadFromPort	  ;PPU.c
;------------------------------------------------------------------------------------
PPU_W
	stmfd sp!,{r3,lr}	;LR 寄存器放栈 
	mov r1,r12
	bl PPU_WriteToPort
	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;--------------------------------------------------------------------------------------
PPU_R
	stmfd sp!,{r3,lr}	;LR 寄存器放栈    会改变R4 
	mov r0,r12
	bl PPU_ReadFromPort	
	ldmfd sp!,{r3,lr}
    orr lr,#0x01
	bx lr
    nop
;-----------------------------------------------------------------------------------------
	AREA cpu_code, DATA, READONLY 
;-----------------------------------------------------------------------------------------		
op_table	   ;DCD 用于分配一段字内存单元 op_table内存块起始地址标号
	DCD _00,_01,_xx,_03,_xx,_05,_06,_07,_08,_09,_0A,_xx,_xx,_0D,_0E,_xx
	DCD _10,_11,_xx,_xx,_14,_15,_16,_xx,_18,_19,_xx,_xx,_xx,_1D,_1E,_xx
	DCD _20,_21,_xx,_xx,_24,_25,_26,_xx,_28,_29,_2A,_xx,_2C,_2D,_2E,_xx
	DCD _30,_31,_xx,_xx,_xx,_35,_36,_xx,_38,_39,_xx,_xx,_xx,_3D,_3E,_xx
	DCD _40,_41,_xx,_xx,_xx,_45,_46,_xx,_48,_49,_4A,_xx,_4C,_4D,_4E,_xx
	DCD _50,_51,_xx,_xx,_xx,_55,_56,_xx,_58,_59,_xx,_xx,_xx,_5D,_5E,_xx
	DCD _60,_61,_xx,_xx,_xx,_65,_66,_67,_68,_69,_6A,_xx,_6C,_6D,_6E,_xx
	DCD _70,_71,_xx,_xx,_xx,_75,_76,_xx,_78,_79,_xx,_xx,_xx,_7D,_7E,_xx
	DCD _xx,_81,_xx,_xx,_84,_85,_86,_xx,_88,_xx,_8A,_xx,_8C,_8D,_8E,_xx
	DCD _90,_91,_xx,_xx,_94,_95,_96,_xx,_98,_99,_9A,_xx,_xx,_9D,_xx,_xx
	DCD _A0,_A1,_A2,_xx,_A4,_A5,_A6,_xx,_A8,_A9,_AA,_xx,_AC,_AD,_AE,_xx
	DCD _B0,_B1,_xx,_xx,_B4,_B5,_B6,_xx,_B8,_B9,_BA,_xx,_BC,_BD,_BE,_xx
	DCD _C0,_C1,_xx,_xx,_C4,_C5,_C6,_xx,_C8,_C9,_CA,_xx,_CC,_CD,_CE,_xx
	DCD _D0,_D1,_xx,_xx,_xx,_D5,_D6,_xx,_D8,_D9,_xx,_xx,_xx,_DD,_DE,_xx
	DCD _E0,_E1,_xx,_xx,_E4,_E5,_E6,_xx,_E8,_E9,_EA,_xx,_EC,_ED,_EE,_xx
	DCD _F0,_F1,_xx,_xx,_xx,_F5,_F6,_xx,_F8,_F9,_xx,_FB,_xx,_FD,_FE,_FF
		                                                         
;---------------------------------------------------------------------------------				
	AREA wram_globals0, DATA, READWRITE
;---------------------------------------------------------------------------------		
cpu_data        ;43*4
	DCD op_table        ;opz #   4      //代码表地址	
  ;readmem_tbl													
	DCD ram_R	;$0000				
	DCD PPU_R	;$2000
	DCD IO_R	;$4000
	DCD sram_R	;$6000
	DCD rom_R80	;$8000
	DCD rom_RA0	;$A000
	DCD rom_RC0	;$C000
	DCD rom_RE0	;$E000
  ;writemem_tbl
	DCD ram_W	;$0000			  
	DCD PPU_W	;$2000	  r0传参数
	DCD IO_W	;$4000
	DCD sram_W	;$6000
	DCD void	;$8000
	DCD void	;$A000
	DCD void	;$C000
	DCD void	;$E000
CPU_RAM   ;memmap_tbl		存储器映象
	DCD NES_RAM		;$0000   0000-7fff	 keep $400 byte aligned for 6502 stack shit
	DCD NES_RAM		;$2000    should应该	  保持1024字节对齐
	DCD NES_RAM		;$4000     never从来没有
	DCD NES_SRAM;   NES_RAM-0x5800	;$6000      change改变
rommap	% 4*4			;$8000-FFFF	 memmap_tbl+16

cpustate
	;group these together for save/loadstate
	% 7*4 ;cpuregs (nz,c,a,x,y,cycles,pc)
	DCD 0 ;m6502_s:
	DCD 0 ;lastbank: 最后MEMMAP添加到PC （用于计算当前的PC ）
	DCD exit_run ;nexttimeout:  jump here when cycles runs out	跳到下一个时钟周期运行
   
    DCD 0   ;rombase # 4			;//ROM开始地址
    DCD 0   ;romnumber # 4		 ;// 
    DCD 0   ;rommask # 4		   ;//ROM掩膜	rommask=romsize-1
		
	DCD 0   ;joy0data # 4	   ;//手柄1串行数据
	DCD 0   ;joy1data # 4	   ;//手柄2串行数据	
clocks		
	DCD 0	;clocksh # 4    ;//执行的时钟数 apu用
cpunmi
    DCD 0   ;cpunmif # 4      ;cpu中断标志
cpuirq
    DCD 0   ;cpuirqf # 4      ;cpu中断标志 		
;	DCW 0	DCW定义16位变量
;----------------------------------------------------------------------------
;	ALIGN           ;通过用零或空指令NOP填充，来使当前位置与一个指定的边界对齐
	END
;align 4
;***************************************************************************************************
;***************************************************************************************************

	;INCLUDE equates.h

	;IMPORT void  ;6502s
	;IMPORT spr_ram		 ;ppu.c
	
	;EXPORT nes_palette	   ;NES $3F00-$3F1F   NES调色板
	;EXPORT PPU_scanline

	;EXPORT nes_nt0
	;EXPORT nes_nt1
	;EXPORT nes_nt2
	;EXPORT nes_nt3

	;EXPORT PPU_BG_HScrlOrg
	;EXPORT PPU_BG_VScrlOrg
	;EXPORT PPU_Latch_Flag  ; 背景位移￥2005写入标志
	;EXPORT PPU_R0;
	;EXPORT PPU_R1;
	;EXPORT PPU_R2;
	;EXPORT PPU_R5;
	;EXPORT PPU_addrcnt
    ;EXPORT PPU_readtemp; 		//读取操作缓冲
	;EXPORT spr_addrcnt  		;spraddrcnt  sprite 地址计数器	  u8

	;EXPORT PPU_R;			   读PPU寄存器
	;EXPORT PPU_W

	

 ;AREA ppu_code, CODE, READONLY
	;PRESERVE8

;addy        RN  r12 ;

;;----------------------------------------------------------------------------
;PPU_R;			   读PPU寄存器
;;----------------------------------------------------------------------------
	;and r0,addy,#7
;;	ldr pc,[pc,r0,lsl#2]  ;//加3行

;;	ldr r1,=PPU_read_tbl   
;;	add r1,r1,r0,lsl#2			  ;<<2			
;;	ldr pc,[r1]			   ;//直接操作pc太他妈危险了
;;	nop

	;tbh     [pc,r0,lsl #1]
;PPU_read_tbl
	;DCI (empty_PPU_R-PPU_read_tbl)/2	;$2000
	;DCI (empty_PPU_R-PPU_read_tbl)/2	;$2001
	;DCI (stat_R-PPU_read_tbl)/2		;$2002
	;DCI (empty_PPU_R-PPU_read_tbl)/2	;$2003
	;DCI (empty_PPU_R-PPU_read_tbl)/2	;$2004
	;DCI (empty_PPU_R-PPU_read_tbl)/2	;$2005
	;DCI (empty_PPU_R-PPU_read_tbl)/2	;$2006
	;DCI (vmdata_R-PPU_read_tbl)/2	;$2007


;;PPU_read_tbl
;;	DCD empty_PPU_R	;$2000
;;	DCD empty_PPU_R	;$2001
;;	DCD stat_R		;$2002
;;	DCD empty_PPU_R	;$2003
;;	DCD empty_PPU_R	;$2004
;;	DCD empty_PPU_R	;$2005
;;	DCD empty_PPU_R	;$2006
;;	DCD vmdata_R	;$2007
;;----------------------------------------------------------------------------
;PPU_W;
;;----------------------------------------------------------------------------
	;and r1,addy,#7
;;	ldr pc,[pc,r2,lsl#2]  ;//改过，加3行

	;ldr r2,=PPU_write_tbl   
	;add r2,r2,r1,lsl#2			  ;<<2			
	;ldr pc,[r2]
	;nop
			
;PPU_write_tbl
	;DCD ctrl0_W		;$2000
	;DCD ctrl1_W		;$2001
	;DCD void		;$2002
	;DCD ppu2003_W	;$2003
	;DCD ppu2004_W	;$2004	
	;DCD bgscroll_W	;$2005
	;DCD vmaddr_W	;$2006
	;DCD vmdata_W	;$2007

;;----------------------------------------------------------------------------
;empty_PPU_R
;;----------------------------------------------------------------------------
	;mov r0,#0
	;orr lr,#0x01		;lr最低位置1防止进入arm状态
	;bx lr

;;----------------------------------------------------------------------------
;stat_R		;(2002)		  读PPU寄存器
;;----------------------------------------------------------------------------
	;mov r0,#0
	;strb r0,toggle		 ;PPU_Latch_Flag = 0;		  //背景位移￥2005写入标志
	;ldrb r0,ppur2	   ;temp = PPU_R2	   	 
	;and r2,r0,#0x7f		 ;PPU_R2 &= 0x7f;
	;strb r2,ppur2
	
	;ldr r1,scanline		; 扫描线   if ((PPU_scanline > 20 && PPU_scanline < 262) && !(PPU_R0 & 0x80))					 
	;cmp r1,#20			;比较  If R1>20 Then （T代表Then，E代表Else）
	;bhi r_2002
	
	;orr lr,#0x01		;lr最低位置1防止进入arm状态
	;bx lr
;r_2002
	;ldrb r1,ppur0		;!(PPU_R0 & 0x80))
	;tst r1,#0x80
	;ldrb r1,ppur0
	;andeq r1,r1,#0xfc		;	!PPU_R0 &= 0xfc;											
	;strb r1,ppur0		 ; ppu寄存器

	;orr lr,#0x01		;lr最低位置1防止进入arm状态
	;bx lr
;;-------------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------
;vmdata_R	;(2007)	  ppu_R		  ////读PPU存储器	  要读ppu存储器的值r0返回
;;----------------------------------------------------------------------------	   													
	;ldr r0,addrcnt		; //保存缓冲值，作为返回值
	;cmp r0,#0x3f00		;if(PPU_addrcnt >= 0x3F00)
	;bhs palread			;r0>=0x3f00就跳到palread
	
	;and r1,r0,#0x3c00
	;adr r2,vram_map		  ;vram_map是8个地址	
	;lsr r1,r1,#8
	;ldr r1,[r2,r1]
	;bic r0,r0,#0xfc00	   ;and 0x03ff
	;ldrb r1,[r1,r0]
	;ldrb r0,readtemp
	;strb r1,readtemp
		
;inc1_32					  ;根据$2002 [bit2] 0：+1  1： +32。	
	;ldr r1,addrcnt
	;ldrb r2,addrcntint
	;add	r1,r1,r2		  ;PPU_R0 & 0x04 ? PPU_addrcnt += 32 : PPU_addrcnt++ ;
	;str r1,addrcnt
	;orr lr,#0x01		;lr最低位置1防止进入arm状态
	;bx lr

;palread					 ;//PPU 读取缓冲不适用 palette 调色板,直接返回
	;and r0,r0,#0x1f
	;adr r1,ppu_palette	 ;读取地址
	;ldrb r0,[r1,r2]
	;b inc1_32

	;nop
;;===================================================================================================
;;----------------------------------------------------------------------------
;ctrl0_W		;(2000)	 //$2000  r0=u8 value
;;----------------------------------------------------------------------------
	;strb r0,ppur0	   	   ;PPU_R0 = value;

	;mov r2,#1			 ;+1/+32 ?  ;根据PPU_R0$2002 [bit2] 0：+1  1： +32。
	;tst r0,#4			;测试（执行按位与操作，并且根据结果更新Z 
	;movne r2,#32		;z=0则r2=32
	;strb r2,addrcntint

	;orr lr,#0x01		;lr最低位置1防止进入arm状态
	;bx lr		
;;----------------------------------------------------------------------------
;ctrl1_W		;(2001)
;;----------------------------------------------------------------------------
	;strb r0,ppur1	   	   ;PPU_R1 = value
	;orr lr,#0x01		;lr最低位置1防止进入arm状态
	;bx lr
;;--------------------------------------------------------------------------------							  	 
;ppu2003_W	;$2003
;;--------------------------------------------------------------------------------------
	;strb r0,spraddrcnt		 ;spr_addrcnt = value;
	;orr lr,#0x01		;lr最低位置1防止进入arm状态
	;bx lr
;;-----------------------------------------------------------------------------
;ppu2004_W	;$2004	
;;-----------------------------------------------------------------------------------
	;ldr r1,=spr_ram	  ;spr_ram[spr_addrcnt++] = value;
	;ldrb r2,spraddrcnt
	;add r2,r2,#1
	;strb r0,[r1,r2]				
	;orr lr,#0x01		;lr最低位置1防止进入arm状态
	;bx lr
;;----------------------------------------------------------------------------------------
;bgscroll_W	;$2005
;;---------------------------------------------------------------------------------------	   	
	;ldrb r1,toggle		;	 if(PPU_Latch_Flag)
	;eors r1,r1,#1		   ;eor Rd, Rn   ; Rd ^= Rn  按位）异或	 异或 按位比较相同为0不同位1
	;strb r1,toggle
	;beq bgscrollY
	;strb r0,bg_hscrlorg	   ;水平scroll数据 else PPU_BG_HScrlOrg = value;//假0：

	;orr lr,#0x01		
	;bx lr
;bgscrollY				;  if(PPU_Latch_Flag) PPU_BG_VScrlOrg	= (value > 239) ? 0 : value;//真1：  	
	;cmp r0,#239			;比较  If r0>239 Then （T代表Then，E代表Else）
    ;movhi r0,#0
    ;strb r0,bg_vscrlorg	 ;垂直scroll数据
    ;orr lr,#0x01		
	;bx lr
;;----------------------------------------------------------------------------
;vmaddr_W	;(2006)
;;----------------------------------------------------------------------------
	;ldrb r1,toggle
	;eor r1,#1	  ;PPU_Latch_Flag ^= 1;		
	;strb r1,toggle		    
				    ;;PPU_addrcnt = (PPU_addrcnt << 8) + value; //PPU 存储器地址计数器，先写高8位，后写低8位
	;ldrb r1,addrcnt		
	;add r2,r0,r1,lsl #8	   ;<<8
	;str r2,addrcnt	

	;orr lr,#0x01		
	;bx lr
	;nop
;;----------------------------------------------------------------------------
;vmdata_W	;(2007)				 	PPU_MemWrite(value);
;;----------------------------------------------------------------------------
	;ldr r1,addrcnt
;;	bic r1,r1,#0xfc000 ;AND $3fff
	;and r1,r1,#0x3c00
	;ldr r2,=ppu_vram_write		  ;vram_write是8个地址	

	;add r1,r2,r1,lsr#8			  ;>>8			
	;ldr pc,[r1]	
	;nop	

;;----------------------------------------------------------------------------
;VRAM_name0	;(2000-23ff)		  //PPU name table 数据	
;;----------------------------------------------------------------------------
	;ldr r1,addrcnt			;name_table[0][PPU_addrcnt & 0xFFF] = value;	//nametable0
;;	and r1,#0x0fff
    ;bic r1,r1,#0xf000
	;ldr r2,nes_nt00		;name_table[0]==nes_nt0
	;strb r0,[r2,r1]
	;b inc1_32	
;;----------------------------------------------------------------------------
;VRAM_name1	;(2400-27ff)
;;----------------------------------------------------------------------------
				 ;;name_table[1][addrtemp - 0x400] = value;		//nametable1
	;ldr r1,addrcnt
	;bic r1,r1,#0xf000
	;sub r1,r1,#0x400
	;ldr r2,nes_nt11
	;strb r0,[r2,r1]
	;b inc1_32
;;----------------------------------------------------------------------------
;VRAM_name2	;(2800-2bff)
;;---------------------------------------------------------------------------
				;;name_table[2][addrtemp - 0x800] = value;
	;ldr r1,addrcnt
	;bic r1,r1,#0xf000
	;sub r1,r1,#0x800
	;ldr r2,nes_nt22
	;strb r0,[r2,r1]	
	;b inc1_32
;;----------------------------------------------------------------------------
;VRAM_name3	;(2c00-2fff)
;;----------------------------------------------------------------------------
			   ;;name_table[3][addrtemp - 0xC00] = value;
	;ldr r1,addrcnt
	;bic r1,r1,#0xf000
	;sub r1,r1,#0xc00
	;ldr r2,nes_nt33
	;strb r0,[r2,r1]	
	;b inc1_32
;;----------------------------------------------------------------------------
;VRAM_pal	;write to VRAM palette area ($3F00-$3F1F)写入VRAM调色板区
;;----------------------------------------------------------------------------	
	;ldr addy,addrcnt	;	 r12
;;	cmp addy,#0x3f00	;$3000 ~ $3EFF	-- $2000 ~ $2EFF的镜像
;;	bmi VRAM_name3

;;	and r0,r0,#0x3f		;(只有颜色0-63都有效)
	;and addy,addy,#0x1f		 ; $3F00-$3F1F
		;tst addy,#0x0f
		;moveq addy,#0	;$10 mirror to $00	镜子 对应位置为透明色的景象
	;adr r1,ppu_palette
	;strb r0,[r1,addy]	;store in nes palette  存储在NES调色板
	;b inc1_32

;;	nop
;;------------------------------------------------------------------------------------------
;ppu_vram_write
	;% 8*4
	;DCD VRAM_name0	;$2000		  |  $2000   |  $23BF   | Name 表 #0                |（960 字节）
	;DCD VRAM_name1	;$2400
	;DCD VRAM_name2	;$2800
	;DCD VRAM_name3	;$2c00		   $2C00   |  $2FBF   | Name 表 #3                |（960 字节）
	;DCD VRAM_name0	;$3000
	;DCD VRAM_name1	;$3400
	;DCD VRAM_name2	;$3800
	;DCD VRAM_pal	;$3c00

;;*******************************************************************************************
;;-------------------------------------------------------------------------------------
	;AREA wram_globals1, DATA, READWRITE
;;-----------------------------------------------------------------------------------------
;ppu_vram_map	;for vmdata_R	vram_map   
	;DCD 0		;图像ROM的8k数据开始地址
	;DCD 0		;图像ROM的8k数据开始地址+1024 
	;DCD 0		;图像ROM的8k数据开始地址+2048
	;DCD 0		;						+3072
	;DCD 0		;						+4096
	;DCD 0	   ;
	;DCD 0		;
	;DCD 0		;图像ROM的8k数据开始地址+7168
;nes_nt0 DCD 0 ;NES_VRAM+0x2000 ;$2000	  显示缓冲区0(VRAM)，与显示屏幕对应的内存区
;nes_nt1 DCD 0 ;NES_VRAM+0x2000 ;$2400	  显示缓冲区1	 name_table[1]
;nes_nt2 DCD 0 ;NES_VRAM+0x2400 ;$2800	  显示缓冲区2	 name_table[2]
;nes_nt3 DCD 0 ;NES_VRAM+0x2400 ;$2c00	  显示缓冲区3	 name_table[3]

			    ;DCD 0 ;vrombase
				;DCD 0 ;vrommask
;PPU_scanline    DCD 0	; scanline	
;PPU_addrcnt	    DCD 0;DCW 0	; addrcnt	u16	
 				;DCD 1		; addrcntint  u8

;PPU_BG_HScrlOrg	DCD 0;DCB 0  ;bg_hscrlorg
;PPU_BG_VScrlOrg	DCD 0;DCB 0  ;bg_vscrlorg
;PPU_Latch_Flag	DCD 0;DCB 0   ;toggle			   背景位移￥2005写入标志	 
;PPU_readtemp 	DCD 0;DCB 0	;readtemp         //读取操作缓冲
;PPU_R0			DCD 0;DCB 0	;ppur0	
;PPU_R1			DCD 0;DCB 0	
;PPU_R2			DCD 0;DCB 0	
;PPU_R5			DCD 0;DCB 0
;spr_addrcnt  	DCD 0;DCB 0	;spraddrcnt  sprite 地址计数器 
			
;;				DCB 0	 ;保持4字节对齐
;;				% 1

;nes_palette	   % 32	;NES $3F00-$3F1F   NES调色板

;;------------------------------------------------------------------------

 ;END

